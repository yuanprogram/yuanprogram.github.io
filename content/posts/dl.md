---
title: "dl"
date: 2025-06-13T18:42:09+08:00
draft: false
---
# 机器学习基础

## 优化算法

### 梯度下降

在每次迭代时，使用整个训练集来计算代价函数的梯度。

随机梯度下降：仅使用一个样本来估计代价函数的梯度，并据此进行参数更新

小批量梯度下降：二者相结合

### 牛顿法

求解非线性方程/优化问题

- 求根：一阶泰勒展开=0，得到迭代公式
- 优化问题： 二阶泰勒展开，对展开式求一阶偏导等于0（即求极小值点）

### 约束优化

#### 拉格朗日乘数法

含有**等式约束**的优化问题：

1. 构造拉格朗日函数：L(*x*,*y*,*λ*)=*f*(*x*,*y*)−*λ*(*g*(*x*,*y*)−*c*)
2. 对参数求梯度等于0求解

#### KKT条件

当含有不等式约束时，

1. **原始可行性**：满足所有原始问题的约束。
2. **对偶可行性**：拉格朗日乘数与不等式约束相联系，且这些**乘数必须非负**。
3. **互补松弛性**：每个**不等式约束**的拉格朗日乘数和对应的约束违反度的乘积为零。
4. **梯度条件**：目标函数和约束函数的梯度线性组合为零。

**对于一些非线性可分问题，将原始问题转化为对偶问题不仅有助于求解，还能自然地结合核技巧，实现高效的非线性分类或回归。** 例如：支持向量机

> 核技巧的核心思想：用内积代替显式的特征映射。核技巧帮助我们在不必明确构造高维特征表示的情况下，享受其带来的好处（捕捉到输入特征之间的非线性关系；直接在高维空间中工作可能会涉及大量的计算成本，包括存储和处理大量数据。核技巧让我们能够*高效地完成这些计算*，而不需要真正执行转换。

# 多层感知机

## 权重衰减

通过对原始损失函数 L(θ)*L*(*θ*) 添加一个额外的正则化项：对权重的平方和进行惩罚（L2正则化）

## 暂退法

应用在激活函数上，在训练时使用可以防止过拟合

在进行前向传播时，先经过线性变换（全连接层或卷积层），然后通过激活函数处理，最后在激活值上应用Dropout。这样做可以确保激活值能够在进入下一层之前被适当地“丢弃”。

激活函数的作用是：引入非线性，，决定神经元是否激活，增加模型的表达能力

## 前向传播与反向传播

![image-20250516153700535](/images/image-20250516153700535.png)

- 前向传播在神经网络定义的计算图中按顺序计算和存储中间变量，它的顺序是从输入层到输出层。

反向传播：从输出层到输入，算梯度。

交替使用前向传播和反向传播，利用反向传播给出的梯度来更新模型参数。 注意，反向传播重复利用前向传播中存储的中间值，以避免重复计算。

## 数值稳定	

梯度消失：sigmoid当输入小或很大时会导致梯度消失。ReLU激活函数缓解了梯度消失问题

梯度爆炸：当层数多，数值太大上溢

隐藏单元：每个神经元都会对输入进行加权求和并加上偏置，然后通过激活函数处理。隐藏单元的大小与权重尺寸有关。隐藏单元大小的设置一般是输入和输出之间的一个值/均值，也可以通过搜索实验验证。

## 模型初始化

- 随机初始化是保证在进行优化前打破**对称性**的关键。这里的对称性指的是参数的对称性

  在神经网络中，如果我们不使用随机初始化，而是采用相同的初始值（例如全部初始化为0或某个常数），那么网络中的各个神经元将是对称的。这意味着，在开始训练时，所有隐藏单元将按照完全相同的方式更新它们的权重，因为它们接收到的输入、初始权重和偏置都是相同的。这种情况下，无论训练多少轮，这些神经元都将保持相同的权重分布，无法学习到不同的特征，极大地限制了模型的学习能力。

- **Xavier初始化**:  根据输入和输出的数量来缩放权重，**旨在**保持每层输入和输出**方差的一致性**，希望网络能够稳定地进行前向传播和反向传播。适用于那些激活函数是对称且非线性不强的情况，如tanh和sigmoid.

![image-20250516204141271](/images/image-20250516204141271.png)

- 两个矩阵乘积特征值的解析界:

  根据公式，找到两个矩阵乘积的最大特征值的一个上界。

  意义在于，了解**权重矩阵乘积的特征值界限**可以帮助我们理解网络在前向和反向传播过程中信号放大或衰减的程度，从而**指导权重初始化策略**的设计，避免梯度消失或爆炸的问题。

  解释：权重矩阵W1和W2（两个连续层的权重矩阵）的乘积W2W1的特征值界限。当我们将多层堆叠在一起时，整个网络的前向传播过程可以看作一系列矩阵乘法操作的结果。因此，了解这些权重矩阵乘积的特征值界限有助于我们理解信号在整个网络中的传播情况，包括是否存在梯度消失或爆炸的风险。

- 发散项的事后修正与按层自适应速率缩放（LARS）: “发散项”通常指的是那些导致模型训练过程不稳定、损失函数值急剧上升或梯度变得异常大的因素。如数据溢出、梯度爆炸。LARS是通过为每一层分配不同的学习率，加速收敛，提高模型的稳定性。

## 环境和分布偏移

- **协变量偏移**：当 Ptrain(x)≠Ptest(x)。数据分布随着时间推移会发生变化。理解和识别这种情况对于构建稳健且可靠的机器学习模型至关重要。

> 纠正：重要性加权法
>
> 1. 生成一个二元分类训练集：{(x1,−1),…,(xn,−1),(u1,1),…,(um,1)}。
>
> 这一步骤创建了一个新的二元分类任务，其中 xi，*i* 表示来自源域（训练数据）的样本，标记为 −1；uj，j 表示来自目标域（测试数据）的样本，标记为 1。这个新任务的目标是区分源域和目标域的数据。
>
> 2. 用对数几率回归**训练二元分类器得到函数 h**。
>
> 在这一步中，使用对数几率回归或其他合适的二元分类算法来训练一个分类器 h，该分类器能够预测一个样本属于源域还是目标域的概率。
>
> 3. 使用 βi=exp⁡(h(xi)) 或更好的 βi=min⁡(exp⁡(h(xi)),c)（*c* 为常量）对训练数据进行加权。
>
> 这一步计算每个源域样本 xi，*i* 的权重 βi。权重 βi反映了该样本在目标域中的相对重要性。具体来说：
>
> - exp⁡(h(xi)) 是基于分类器 h*h* 输出的概率值计算的权重。
>
> - min⁡(exp⁡(h(xi)),c)是为了避免权重过大导致数值不稳定或过拟合，通过设置一个上限 c*c* 来限制权重的最大值。
>
>   因为对数几率回归是对h作sigmoid，![image-20250517204923090](/images/image-20250517204923090.png)
>
>   样本属于目标域的概率/属于源域的概率
>
> 4. 使用权重 βi 进行中{(x1,y1),…,(xn,yn)} 的训练。
>
> 最后一步是在原始的监督学习任务中使用这些计算出的权重 βi对训练数据进行加权训练。这意味着在计算损失函数时，**每个样本的损失会被乘以其对应的权重 βi**，从而使得模型更加关注那些在目标域中更具有代表性的样本。

- **标签偏移**：即 Ptrain(y)≠Ptest(y)

> 纠正：密度比估计进行加权
>
> 1. **估计源域和目标域的类别分布**：
>    - 对于源域，可以直接从训练数据中统计得到 p(y)。
>    - 对于目标域，可能需要一些带标签的目标域数据来估计 q(y)，或者使用无监督方法尝试估计。
> 2. **计算每个样本的权重**：
>    - 根据上述公式 wi=q(yi)/p(yi)计算每个样本的权重。
> 3. **加权训练模型**：
>    - 在训练过程中，对每个样本的损失函数乘以其对应的权重 wi，然后最小化加权后的总损失。

- **概念偏移**：*P*train(*y*∣*x*)\\=*P*test(*y*∣*x*) 。这种情况下，模型基于旧数据学习到的关系不再适用于新数据，导致性能下降。

> 纠正：我们可以使用与训练网络相同的方法，使其适应数据的变化。 换言之，我们使用**新数据更新**现有的网络权重，而不是从头开始训练。



截至目前，接触到的机器学习问题都属于**批量学习 (batch learning)**，成批地学习数据特征，并在模型完善后不再更新。而环境中已经发生的事件将改变可能性事件发生的概率。**在线学习 (online learning)** 能在给出预测后，记录随后的真实情况，根据预测结果的准确性实时奖励或惩罚模型，不断更新模型参数。

控制理论中的比例-积分-微分 (Proportional-Integral-Derivative, **PID**) **控制算法**，能根据环境中的反馈机制，自动调整模型超参数。而**强化学习 (reinforcement learning)** 是基于智能体与环境的交互和试错，最大化长期累积的奖励学习最优策略（**老虎机 (Arm)**）。

# 深度学习计算

## 参数管理

共享参数

```python
shared = nn.Linear(8, 8)
net = nn.Sequential(
    nn.Linear(4, 8), 
    nn.ReLU(),
    shared,           # 第一个引用
    nn.ReLU(),
    shared,           # 第二个引用（共享同一层）
    nn.ReLU(),
    nn.Linear(8, 1)
)
```

两个 `shared` 层其实是**同一个对象**。也就是说，它们共享所有的参数（权重和偏置）。因此，在反向传播时，这个共享层会根据两个不同位置的梯度更新，使得它的参数同时受到两次前向传播路径的影响。

## 延后初始化

即直到数据第一次通过模型传递时，框架才会动态地推断出每个层的大小。

```python
"""延后初始化"""
net = nn.Sequential(nn.LazyLinear(256), nn.ReLU(), nn.LazyLinear(10))
# print(net[0].weight)  # 尚未初始化
print(net)
```



## 自定义层

设计一个接收输入并张量降维的层

```python
class TensorReduceLayer(nn.Module):
    def __init__(self, input_shape, output_dim):
        """
        初始化TensorReduceLayer。
        参数:
            input_shape (tuple): 输入张量的形状，例如 (i, j)
            output_dim (int): 输出张量的维度 k
        """
        super(TensorReduceLayer, self).__init__()
        
        # 获取输入张量的维度
        i, j = input_shape
        
        # 初始化权重张量 W_ijk
        self.weight = nn.Parameter(torch.randn(output_dim, i, j))
        
    def forward(self, x):
        """
        前向传播函数。
        
        参数:
            x (torch.Tensor): 输入张量，形状为 (batch_size, i, j)
            
        返回:
            torch.Tensor: 输出张量，形状为 (batch_size, output_dim)
        """
        # 扩展权重张量以匹配输入张量的批量大小
        weight_expanded = self.weight.unsqueeze(0).expand(x.size(0), -1, -1, -1)
        
        # 将输入张量扩展到与权重张量相同的维度
        x_expanded = x.unsqueeze(1).expand(-1, self.weight.size(0), -1, -1)
        
        # 计算 y_k = sum_ij(W_ijk * x_ij)
        y = torch.sum(weight_expanded * x_expanded, dim=(2, 3)) 
        
        return y
```

张量的*指的是逐元素相乘

## 读写文件

- `save`和`load`函数可用于张量对象的文件读写。
- 我们可以通过**参数字典**保存和加载网络的全部参数。
- 保存架构必须在代码中完成，而不是在参数中完成。



保存整个模型：

```
torch.save(model, 'model.pth')
model = torch.load('model.pth')
```

仅参数（推荐）：防止有自定义层导致不兼容

```
torch.save(model.state_dict(), 'model_state_dict.pth')
model.load_state_dict(torch.load('model_state_dict.pth'))
```

如果想复用部分层：先定义模型架构，基于初始化后的模型实例提取所需的层，并将其应用于新的网络架构中。

# 卷积神经网络

平移不变性、局部性

1、当卷积层覆盖的局部区域为0时，即卷积核为1*1。卷积核为每组通道独立地实现一个全连接层。

2、当从图像边界像素获取隐藏表示时，我们需要思考哪些问题？

卷积核可能超过边界（填充）；边界像素上下文较少

- 学习卷积核：找到一个卷积核符合输入到输出的映射

  ```python
  # 构造一个二维卷积层，它具有1个输出/输入通道和形状为（1，2）的卷积核
  conv2d = nn.Conv2d(1,1, kernel_size=(1, 2), bias=False)
  
  # 这个二维卷积层使用四维输入和输出格式（批量大小、通道、高度、宽度），
  # 其中批量大小和通道数都为1
  X = X.reshape((1, 1, 6, 8))//先前有x，y的定义
  Y = Y.reshape((1, 1, 6, 7))
  lr = 3e-2  # 学习率
  
  for i in range(10):
      Y_hat = conv2d(X)
      l = (Y_hat - Y) ** 2
      conv2d.zero_grad()
      l.sum().backward()
      # 迭代卷积核
      conv2d.weight.data[:] -= lr * conv2d.weight.grad
      if (i + 1) % 2 == 0:
          print(f'epoch {i+1}, loss {l.sum():.3f}')
  ```

  **填充和步幅**

  ```
  conv2d = nn.Conv2d(1, 1, kernel_size=(3, 5), padding=(0, 1), stride=(3, 4))
  ```

  填充padding(高度，宽度)

  步长stride(高度，宽度)

## 多输入 多输出

- **输入通道数**决定了每个卷积核的深度（或者说每个卷积核有多少个切片）。
- **输出通道数**决定了卷积层中有多少组卷积核，每组卷积核负责生成一个输出特征图。

例如：如果我们希望有4个输出通道，那么就会有4组卷积核，每组包含两个卷积核切片（因为输入有2个通道），总共8个卷积核。每一组卷积核都对输入通道进行卷积（每个切片的卷积之和）对应每个输出通道的结果

## 汇聚层（池化层）

- 降低卷积层对位置的敏感性：将局部区域的信息合并（例如取最大值或平均值），减少了输出对于输入中微小位移的敏感度。
- 降低对空间降采样表示的敏感性。

对于给定输入元素，最大汇聚层会输出该窗口内的最大值，平均汇聚层会输出该窗口内的平均值。

汇聚层的输出通道数与输入通道数相同

## 卷积神经网络

### **经典**的：LeNet, AlexNet

经典卷积神经网络的基本组成部分是下面的这个序列：

1. 带填充以保持分辨率的卷积层；
2. 非线性激活函数，如ReLU；
3. 汇聚层，如最大汇聚层。

### VGG块：

由一系列卷积层+最大池化层构成。形成可复用的卷积块构造网络，使得网络定义非常简洁。发现深层且窄的卷积（即3×3）比较浅层且宽的卷积更有效。原因：

- 更强的**非线性**建模能力（更多的激活函数，卷积层后面一般会加激活函数
- 更少的参数和更高的计算效率
- 更大的感受野和更好的特征表达
- 更适合现代正则化与优化策略（如残差连接、BN）

### NiN：

使用由一个卷积层和多个1×1卷积层（也被视为多层感知机应用于每个空间位置）组成的块。该块可以在卷积神经网络中使用，以允许更多的每像素非线性。去除了容易造成过拟合的全连接层，将它们替换为全局平均汇聚层（即在所有位置上进行求和）。该汇聚层通道数量为所需的输出数量。

> 对于每一个空间位置（或者说每一个像素点），1×1卷积都会对其所有输入通道进行一次独立的线性组合。如果考虑多个连续的1×1卷积层，这就像是为每个像素点单独配置了一个小型的全连接网络或多层感知机（MLP）。每层1×1卷积都可以视为MLP的一层，其中权重矩阵是可训练参数。

### 含并行连接（GoogleNet)

GoogLeNet一共使用9个Inception块和全局平均汇聚层的堆叠来生成其估计值

![image-20250520110120347](/images/image-20250520110120347.png)

### 批量规范化

在每个小批量数据（mini-batch）上规范化层的输入，使得其均值接近0，方差接近1。通过不断调整神经网络的中间输出，使整个神经网络各层的中间输出值更加稳定。

1. 删除偏置参数

在使用批量规范化之前，**可以从全连接层或卷积层中删除偏置参数**。这是因为批量规范化本身包含了一个平移参数（β），它起到了类似偏置的作用。通过调整β*β*，可以实现对输入数据的平移变换，从而使得额外的偏置变得不必要。

2. LeNet在使用和不使用批量规范化情况下的学习率比较

**没有批量规范化**：通常需要较小的学习率，并且可能需要更精细地调整其他超参数来确保训练过程的稳定性。**有批量规范化**：由于BN减少了内部协变量转移，模型往往能够容忍更高的学习率，这可以加速收敛并有助于找到更好的解.

3. 是否需要在每个层中进行批量规范化？

并不是必须在每个层中都应用批量规范化。实践中，通常会在**卷积层或全连接层之后应用BN**，特别是在深层网络中。然而，是否需要在所有地方都使用BN应基于实际效果决定。有时，在靠近输入层的地方减少BN的使用可能会带来更好的性能。

4. 批量规范化能否替换暂退法？

批量规范化与暂退法（Dropout）有不同的目的：BN主要解决的是训练过程中的不稳定性和加速收敛；而Dropout则是为了防止过拟合。虽然BN确实提供了一些正则化效果，但它并不能完全替代Dropout的功能。在一些情况下，结合使用两者可能会得到最好的结果。

5. 确定参数Beta和Gamma

Beta (β*β*) 和 Gamma (γ*γ*) 是批量规范化中的可学习参数，分别用于控制输出的平移和缩放。默认情况下，*β* 初始化为0，*γ* 初始化为1。它们会随着训练自动调整，以优化模型的表现。

### 残差网络

每个附加层都应该更容易地包含原始函数作为其元素之一。这有助于训练过程中梯度的反向传播，从而能训练出更深的CNN网络

![image-20250520112519681](/images/image-20250520112519681.png)

- **恒等映射**：当残差块中的所有权重和偏置都设为0时，该块执行的是恒等映射。f(x)=x
- **残差映射**：即使目标映射接近恒等映射，通过学习微小的残差 *H*(*x*)，模型仍能有效捕捉到这些细微的变化

### DenseNet

前面所有层与后面层的密集连接

稠密块+过渡块：DenseNet网络中使用DenseBlock+Transition的结构，其中DenseBlock是包含很多层的模块，每个层的特征图大小相同，层与层之间采用**密集连接方式**。而Transition模块是连接两个相邻的DenseBlock，并且通过Pooling使特征图大小降低。

transition:

- 1. BN + ReLU + 1×1卷积: 降低模型复杂度
  2. **平均池化（AvgPool）**：将特征图的空间尺寸缩小一半（例如从32x32变为16x16）。

#### 示例：

**Dense Block**：中，每层的输入是前面所有层的拼接。其中会加入1*1的卷积作为瓶颈层，位于每个3×3卷积之前，用于减少输入特征图的数量，降低后续3* *3卷积的复杂度

# 循环神经网络

## 序列模型

1、自回归模型

使用固定长度的观测序列，使参数的数量不变

它假设当前时刻的观测值可以表示为过去若干个时刻观测值的线性组合，再加上一个随机误差项。

**局限性**：

- 只能捕捉线性关系。
- 需要手动选择阶数 p*p*。
- 对于复杂的非线性时间序列可能表现不佳。

2、隐变量自回归模型

保留对过去观测的总结，并同时更新预测和总结。适用于当观测数据不足以完全描述系统状态时

**核心思想**：

1. **保留对过去观测的总结**：通过隐变量 ht*h**t* 来总结截止到时间 t*t* 的所有历史观测信息 x1:t*x*1:*t*。

2. **同时更新预测和总结**：

   - 在每一步 *t*，模型根据当前的隐变量 更新隐状态 ht。
   - 然后基于 ht 预测下一个时刻的观测值 xt+1。

   *ht*=*f*(*ht*−1,*xt*)     xt+1=g(ht)    

**特点**：

1. **动态隐状态**：隐变量 ht 随着时间动态更新，可以灵活地捕捉长期依赖关系。
2. **参数共享**：函数 f*f* 和 g*g* 的参数在所有时间步共享，因此参数数量是固定的。
3. **更强的表达能力**：通过隐变量可以捕捉更复杂的非线性关系和长期依赖。
4. **典型例子**：
   - 循环神经网络（RNN）：RNN 是一种隐变量自回归模型，其中 ht是隐藏状态，通过递归更新。
   - 隐马尔可夫模型（HMM）：HMM 也是一种隐变量模型，但通常用于状态空间模型而非自回归预测。

### 马尔可夫模型

*P*(*Xt*+1=*j*∣*Xt*=*i*)=*pij*    

- **马尔可夫模型**的核心是下一状态仅依赖当前状态。
- **计算多步转移**需要逐步或通过矩阵乘法实现

序列模型估计的例子：

**单步预测和多步预测**：

单步预测 根据前tau个真实数据预测下一个值。每一个预测都是基于真实值的

多步预测 根据前tau个预测数据预测下一个值。导致了误差的累积。

k步预测指的是，预测k个数据。k是预测步数，tau是窗口大小

## 文本预处理

1. 将文本作为字符串加载到内存中。

2. 将字符串拆分为词元（如单词和字符）。

   > 词元化：
   >
   > **词元（Token）**是文本的最小语义单位，可以是单词、子词、字符或符号。

3. 建立一个词表，将拆分的词元映射到数字索引。

4. 将文本转换为数字索引序列，方便模型操作。

## 语言模型

**齐普夫定律** 揭示了自然语言中词频的幂律分布特性。
$$
f_r = \frac{C}{r^{\alpha}}
$$
r是频率排名，fr是频率

n元语法中，随着n的增加，α也增加，因为组合的稀疏性

### **n元语法**

- **n-gram 的“n”** 指的是**序列中词元的数量**，而非“依赖的前置词数量”。
  - **Bigram（2-gram）**：序列是 `[w_{t-1}, w_t]`（共 2 个词），但只依赖前 1 个词。
  - **Trigram（3-gram）**：序列是 `[w_{t-2}, w_{t-1}, w_t]`（共 3 个词），依赖前 2 个词。
  - **Unigram（1-gram）**：序列是 `[w_t]`（仅 1 个词），**无依赖**（独立概率）。

例如，bigram（2-gram）模型：
P("我爱NLP") = P("我") × P("爱"|"我") × P("NLP"|"爱")

这个例子每一个词是由前个词推出来的，每个条件概率的计算基于 **2 个词的组合**

### 读取长序列数据

#### 随机采样

- 从长序列中**随机截取**固定长度的子序列，**打乱原始顺序**。
- 适用于**非时序敏感任务**（如语言模型预训练、文本分类）

#### 顺序分区

### **核心思想**

- 将长序列**按顺序分割**为连续的子序列，**保留时序关系**。
- 适用于**时序敏感任务**（如机器翻译、股票预测）

## 循环神经网络

**RNN对具有序列特性的数据非常有效，它能挖掘数据中的时序信息以及语义信息，**利用了RNN的这种能力，使深度学习模型在解决语音识别、语言模型、机器翻译以及时序分析等NLP领域的问题时有所突破。

利用上下文信息

![image-20250529162216218](/images/image-20250529162216218.png)



![image-20250529163115650](/images/image-20250529163115650.png)

![image-20250529165721877](/images/image-20250529165721877.png)

### 困惑度

- **数学定义**：
  给定测试集 D={w1,w2,...,wN}D={*w*1​,*w*2​,...,*wN*​}，困惑度为交叉熵损失的指数形式：

  PP=exp⁡(−1/N∑log⁡P(wi∣w1,...,wi−1))

  - P(wi∣w1,...,wi−1) 是模型预测当前词的概率。
  - N*N* 是测试集的总词数。

- **直观意义**：

  - 困惑度 ≈ **“模型在预测下一个词时的平均分支数”**。
    - 例如，PP=50 表示模型平均在50个可能的词中犹豫不决

### 简洁实现

```python
batch_size, num_steps = 32, 35
train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps)
num_hiddens = 256
rnn_layer = nn.RNN(len(vocab), num_hiddens)
state = torch.zeros((1, batch_size, num_hiddens))
X = torch.rand(size=(num_steps, batch_size, len(vocab)))
Y, state_new = rnn_layer(X, state)

#@save
class RNNModel(nn.Module):
    """循环神经网络模型"""
    def __init__(self, rnn_layer, vocab_size, **kwargs):
        super(RNNModel, self).__init__(**kwargs)
        self.rnn = rnn_layer
        self.vocab_size = vocab_size#词汇表的大小（即输出维度）
        self.num_hiddens = self.rnn.hidden_size
        # 如果RNN是双向的（之后将介绍），num_directions应该是2，否则应该是1
        if not self.rnn.bidirectional:
            self.num_directions = 1
            self.linear = nn.Linear(self.num_hiddens, self.vocab_size)
        else:
            self.num_directions = 2
            self.linear = nn.Linear(self.num_hiddens * 2, self.vocab_size)

    def forward(self, inputs, state):
        X = F.one_hot(inputs.T.long(), self.vocab_size)
        X = X.to(torch.float32)
        Y, state = self.rnn(X, state)
        # 全连接层首先将Y的形状改为(时间步数*批量大小,隐藏单元数)
        # 它的输出形状是(时间步数*批量大小,词表大小)。
        output = self.linear(Y.reshape((-1, Y.shape[-1])))
        return output, state #返回输出和隐状态

    def begin_state(self, device, batch_size=1):
        if not isinstance(self.rnn, nn.LSTM):
            # nn.GRU以张量作为隐状态
            return  torch.zeros((self.num_directions * self.rnn.num_layers,
                                 batch_size, self.num_hiddens),
                                device=device)
        else:
            # nn.LSTM以元组作为隐状态
            return (torch.zeros((
                self.num_directions * self.rnn.num_layers,
                batch_size, self.num_hiddens), device=device),
                    torch.zeros((
                        self.num_directions * self.rnn.num_layers,
                        batch_size, self.num_hiddens), device=device))
```

模型的参数有：vocab_size,  hidden_size, rnn, linear

前向传播：独热编码/嵌入层，RNN层，全连接层，返回输出和状态

- 独热编码one-hot

  - 符号 wi的独热编码 **v**i：

    vi=[0,…,1,…,0]（第 i 位为1）

  简单直观，易于实现。但词汇表很大时不行（高维稀疏），没有语义信息

- 嵌入层Embedding

  将符号映射到一个低维稠密向量空间（通常维度为 `embed_size`）

  向量值通过训练学习得到

  低维稠密，可学习语义，参数高效

### 通过时间反向传播

RNN 的梯度需要沿 **时间维度** 和 **网络深度** 两个方向传播：

1. **时间方向**：从 t=T 到 t=1，计算每个时间步的梯度。
2. **层方向**：对参数 Wxh,Whh,Why 求导。

损失是所有时间步损失的和，

计算某时间点的损失对whh的梯度时，链式法则循环计算，会导致梯度爆炸/消失。

所以，采用截断：分为子序列分别采用BPTT。

固定截断（将序列均分为等长的块）；随机截断

M的k次幂乘x，趋向主特征向量。长期梯度方向由 J 的主特征向量主导，幅度由 λ1 决定。

- **梯度爆炸**：主特征值 λ1>1*λ*1>1 时，梯度方向稳定（v1*v*1），但数值不稳定。
- **梯度消失**：主特征值 λ1<1*λ*1<1 时，梯度方向仍为 v1*v*1，但幅度趋近 0，导致参数无法更新。
- **解决方案**：
  - 梯度裁剪（控制爆炸）。
  - 使用 LSTM/GRU（通过门控机制调节特征值）。

### 门控循环单元GRU

重置门rt：控制前一时刻隐藏状态 ht−1对当前候选状态 ht 的影响。

> 若rt≈0，丢弃ht-1.ht主要依赖于xt重置门打开时，门控循环单元包含基本循环神经网络
>
> 捕获短期依赖：因为局部信息依赖，是处理最近几步的历史信息；主动丢弃无关历史

更新门zt：决定隐藏状态 ht中保留多少旧状态 ht−1或更新为新候选状态 h~t

> 若zt≈0，保留大部分旧。*ht*≈ht−1更新门打开时，门控循环单元可以跳过子序列。
>
> 捕获长期依赖：记忆持久化，可以抑制状态更新，也可以渐进式更新。
>
> 当更新门打开时，前向传播丢弃了旧状态，反向传播的梯度被截断，无法优化远距离时间步的参数。

工作流程：重置门先筛选信息，生成候选状态，更新门绝对最终状态

![image-20250603153040926](/images/image-20250603153040926.png)

这是候选隐状态，由Rt控制Ht-1

![image-20250603153719158](/images/image-20250603153719158.png)

隐状态有来自旧状态和新候选状态。

### 长短期记忆网络LSTM

LSTM（长短时记忆网络）是一种常用于处理序列数据的深度学习模型，与传统的 RNN（循环神经网络）相比，LSTM引入了三个门（ **输入门、遗忘门、输出门**，如下图所示）和一个 **细胞状态**（cell state），这些机制使得LSTM能够更好地处理序列中的**长期依赖关系**

- **细胞状态 Ct**：贯穿整个时间步的“记忆通道”，负责**长期信息**的传递。
- **门控机制**：调节信息的流入、保留和遗忘，包括：
  1. **遗忘门（Forget Gate）**：决定丢弃哪些历史信息。
  2. **输入门（Input Gate）**：决定哪些新信息存入细胞状态。
  3. **输出门（Output Gate）**：决定当前隐藏状态的输出。

![img](https://i-blog.csdnimg.cn/blog_migrate/c4751f800ebe179a04d700633eac49af.png)

### 深度循环网络

隐藏层加深。隐状态的信息被传递到当前层的下一时间步和下一层的当前时间步。

### 双向循环神经网络

添加了反向传递信息的隐藏层。每个时间步的隐状态由当前时间步的前后数据同时决定。双向循环神经网络主要用于序列编码和**给定双向上下文**的观测估计。

优点是：上下文感知；性能提升

缺点是：计算成本高，无法实时处理

**实现过程**：

通过**两个独立的RNN**并行处理序列：

- **正向RNN**：从左到右计算隐藏状态 h→t*h**t*，捕获**上文信息**（和传统RNN相同）。
- **反向RNN**：从右到左计算隐藏状态 h←t*h**t*，捕获**下文信息**（xt,xt+1,…,xT*x**t*,*x**t*+1,…,*x**T*）

例子

原始序列:    A       B       C       D
            t=1     t=2     t=3     t=4

正向RNN:   → h1 →   → h2 →   → h3 →   → h4 →
            |A       |A,B     |A,B,C   |A,B,C,D

反向RNN:   ← h4 ←   ← h3 ←   ← h2 ←   ← h1 ←
            |D,C,B,A |D,C,B   |D,C     |D

合并输出:
h1 = [→h1(A); ←h4(D,C,B,A)]  # A的上下文：左边无词，右边D,C,B
h2 = [→h2(A,B); ←h3(D,C,B)]  # B的上下文：左边A，右边D,C
h3 = [→h3(A,B,C); ←h2(D,C)]  # C的上下文：左边A,B，右边D
h4 = [→h4(A,B,C,D); ←h1(D)]  # D的上下文：左边A,B,C，右边无词

### 编码器-解码器架构

普通RNN仅处理单序列（如分类或预测）,而这个专门用于**序列转换任务**。串行，编码和解码严格分离

- **编码器**：将输入序列（如句子）压缩为**固定长度的上下文向量**（Context Vector），捕获全局语义。
- **解码器**：基于上下文向量逐步生成输出序列（如翻译结果）。

### 序列到序列学习seq2seq

这个一个任务框架。

早期采用编码器-解码器架构。

后面采用的是Transformer

#### 评估

基于文本相似度：BLEU,ROUGE

基于语义相似度：BERTScore，BLEURT

**BLEU**

![image-20250604145320377](/imagesimage-20250604145320377.png)

当预测序列和标签序列完全相同时，BLEU为1

### 束搜索

贪心：每个时间步选取概率最大的一个输出。不保证全局最优。

穷举搜索：穷举地列举所有可能的输出序列及其条件概率， 然后计算输出条件概率最高的一个。计算量很大

束搜索：贪心的改进。每一步扩展当前保留的所有路径，然后从中**选择k个最优**的继续

# 注意力机制

## 三要素：查询、键、值

**查询（自主性提示）**：代表模型当前需要关注的目标或任务需求。是搜索提示

**键（非自主性提示）**：是输入数据的特征表示，用于与查询匹配。

**值（感官输入）**：是键对应的实际内容。

每个键对应一个值，键用于计算与查询的匹配度（注意力分数），值则是最终被聚合的信息。



## 注意力汇聚

加权平均，**根据查询（Query）动态决定不同输入部分的重要性**，而非对所有输入一视同仁。
$$
\text{Output} = \sum_{i=1}^n \alpha(q, k_i) \cdot v_i
$$
**非参数型注意力汇聚**：

没有可训练参数，注意力权重仅由Query,Key的相似度计算


$$
\alpha(q, k_i) = \text{softmax}(f(q, k_i)) = \frac{e^{f(q, k_i)}}{\sum_{j=1}^n e^{f(q, k_j)}}
$$
f是相似度函数：点积；高斯核；

**带参数型注意力汇聚**：

可训练参数(权重矩阵），适用于复杂任务（Transformer)
$$
q = W^Q x_q, \quad k_i = W^K x_i, \quad v_i = W^V x_i
$$

$$
\alpha(q, k_i) = \text{softmax}\left( \frac{q^T k_i}{\sqrt{d}} \right)（缩放点积）
$$

Wq可学习如何生成更有效的 Query，从而更好地聚焦关键信息。

*WK* 可以学习如何提取对任务更重要的特征（如句法、语义信息）

*WV* 可以动态调整 Value 的表示，使其更适合当前任务。（如机器翻译需要语义，语音识别需要声学特征）

## 注意力评分函数

用于计算**查询（Query）**和**键（Key）**之间的相关性，决定了模型对输入数据的关注程度。

上文的f(q, k_i)就说注意力评分函数。

这里是指函数本身不需要参数。

但上文的参数行注意力汇聚是q，k，v带参数

| **评分函数** | **是否需要参数** | **适用场景**         |
| :----------- | :--------------- | :------------------- |
| 点积         | ❌                | 低维向量             |
| 缩放点积     | ❌                | Transformer          |
| 加性注意力   | ✅                | **查询和键维度不同** |
| 余弦相似度   | ❌                | 文本匹配             |
| 高斯核       | ❌                | 非参数模型           |

$$
f(q, k_i) = q^\top k_i 点积
$$

$$
f(q, k_i) = \frac{q^\top k_i}{\sqrt{d}}缩放点积
$$

$$
f(q, k_i) = \mathbf{v}^\top \tanh(\mathbf{W}_q q + \mathbf{W}_k k_i)加性注意力
$$

$$
f(q, k_i) = \frac{q^\top k_i}{\|q\| \cdot \|k_i\|}余弦相似度
$$

$$
f(q, k_i) = -\frac{\|q - k_i\|^2}{2\tau^2}高斯核
$$

当查询和键是不同长度的矢量时，可以使用可加性注意力评分函数。当它们的长度相同时，使用缩放的“点－积”注意力评分函数的计算效率更高

## Bahdanau注意力（加性注意力）

通过**动态加权**解决传统编码器-解码器中固定长度上下文向量的局限性。

在循环神经网络编码器-解码器中，Bahdanau注意力将上一时间步的**解码器隐状态视为查询**，在所有时间步的编码器隐状态同时视为键和值

将上下文变量视为加性注意力池化的输出

传统的seq2seq的编码器将整个输入序列压缩为一个**固定**向量（如LSTM最后隐藏状态），所有解码步骤共用该向量。带注意力的在每一步解码时，通过注意力权重重新计算上下文变量：
$$
\begin{aligned}
\mathbf{c}_t &= \sum_{i=1}^n \alpha_{ti} \mathbf{h}_i \\
\alpha_{ti} &= \text{softmax}(e_{ti}) \\
e_{ti} &= \mathbf{v}^\top \tanh(\mathbf{W}_q \mathbf{s}_{t-1} + \mathbf{W}_k \mathbf{h}_i)
\end{aligned}
$$
这里用的加性注意力

## 多头注意力

通过**并行学习多组注意力模式**，显著提升了模型捕捉不同特征关系的能力：将输入投影到多组子空间，每组独立计算注意力，最后合并结果。

修剪最不重要的注意力头：先用权重方差（每个头的方差。**越小越不好**）快速筛选，再通过梯度（对每个头的输出计算梯度范数）显著性确认，最后用消融实验验证关键头。

**梯度范数小** → 改变该头的输出对损失影响微弱，说明它对任务贡献小。

## 自注意力

每个查询都会关注所有的键－值对并生成一个注意力输出。这里三者来自同一输入序列。普通的注意力Q来自解码器当前状态，K/V来自编码器的输出序列。

| **特性**         | 说明                                                       | 示例                                                    |
| :--------------- | :--------------------------------------------------------- | :------------------------------------------------------ |
| **置换不变性**   | 输出仅依赖元素间关系，与输入顺序无关（需额外添加位置编码） | 句子“猫追狗”和“狗追猫”的语义差异需靠位置编码区分        |
| **长程依赖建模** | 直接计算任意两位置关系，不受距离限制                       | 段落开头与结尾的指代关系可一步捕捉                      |
| **并行计算**     | 所有位置的Q/K/V矩阵运算可同步完成                          | 相比RNN的O(n)时序计算，自注意力可并行化（硬件利用率高） |

- 卷积神经网络和自注意力都拥有并行计算的优势，而且自注意力的最大路径长度最短。但是因为其计算复杂度是关于序列长度的二次方，所以在很长的序列中计算会非常慢。
- 为了使用序列的顺序信息，可以通过在输入表示中添加位置编码，来注入绝对的或相对的位置信息。

流程：

1. 输入嵌入（将词转化为向量）+位置编码（将位置编码和词向量相加）
2. 生成QKV
3. 计算注意力权重（缩放点积）
4. 加权聚合+输出

位置编码：

1. 基于正弦和余弦函数的固定位置编码
2. 可学习的，将位置编码作为可训练的嵌入矩阵
3. 相对位置编码
4. 旋转位置编码
